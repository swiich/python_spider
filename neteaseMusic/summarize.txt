    整理代码的时候乱七八糟因为某个地方多加了一个括号特别不明显，浪费了半个小时，各种弯路走得太多


    本来通过网页的post请求解析发现要得到所有的playlist(大于36)要分两步:
    第一步初始化页面params包含的参数    (uid type limit offset total csrf_token)
    第二步动态加载剩余页面params包含的参数    (uid wordwrap offset total limit csrf_token)
    两个步骤的传递参数是不同的，也就是如果歌单总量超过36(页面初始化默认36个歌单)每一次下拉需要传递的参数是不同的，会随着下次次数的变化而变化
    但是循环发现如果传递不同的参数每一次都只会返回36个，并不是总量
    但是通过程序debug发现，要返回用户所有的歌单总量，只需要发送初始化页面的参数，动态加载的参数没用，原因未知


    判断下拉是否还存在歌单(目前想到可行方法之一：爬取用户自创歌单与收藏歌单相加得到歌单总数/36=n,总数小于36则不下拉爬取1次，n无余数则下拉n+1次，有余数则下拉n次)
    case1  amount<36 1     case2  amount>36 && amount%36!=0  n=amount/36  times=n+1     case3   amount%36=0   times=n
    思考如何传下拉参数花了大量时间，结果动态加载的参数通过后来的证明并没有什么卵用，和初始化参数一样


    selenium为了达到跨平台跨浏览器的目的，采用了通过javascript来驱动浏览器动作的方法，所以其速度基于浏览器解析引擎

    
    返回歌单中的歌曲信息无序，并不一定是根据歌单中顺序，歌曲ID与name采用的键值对，字典储存无序


    关于数据库设计
    (11/15)目前实现功能为，手动输入UID，可获取{自创歌单ID，收藏歌单ID，歌单详情，歌单中歌曲ID+name, 歌单中歌曲top100}
    uid（uid）
    用户喜欢top100(uid,songId）
    歌曲信息songid对应的songName(songId,songName)
    



    关于断点日志记录，多线程并发